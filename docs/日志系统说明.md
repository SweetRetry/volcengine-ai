# 日志系统说明

## 📋 概述

本项目实现了完整的日志管理系统，支持同时输出到控制台和本地文件，并提供自动日志轮转和清理功能。

## 🚀 功能特性

### 双输出模式
- **控制台输出**: 实时查看日志信息
- **文件输出**: 持久化存储，便于后续分析
- **同步输出**: 使用 `io.MultiWriter` 确保两个输出源同步

### 按日期分类
- **文件命名**: `app-YYYY-MM-DD.log` 格式
- **自动创建**: 每天自动创建新的日志文件
- **目录管理**: 所有日志文件存储在 `logs/` 目录下

### 自动轮转
- **定时轮转**: 每天午夜自动切换到新的日志文件
- **手动轮转**: 支持通过API或命令手动触发轮转
- **无缝切换**: 轮转过程不影响日志记录

### 自动清理
- **保留策略**: 默认保留7天的日志文件
- **定时清理**: 每天自动清理过期日志
- **可配置**: 通过环境变量配置保留天数

## ⚙️ 配置说明

### 环境变量

```bash
# 日志级别 (debug, info, warn, error)
LOG_LEVEL=info

# 日志保留天数
LOG_KEEP_DAYS=7
```

### 日志格式

使用JSON格式，包含以下字段：
- `time`: 时间戳 (2006-01-02 15:04:05)
- `level`: 日志级别
- `msg`: 日志消息
- `fields`: 结构化字段（如果有）

示例：
```json
{
  "time": "2024-01-15 10:30:45",
  "level": "info",
  "msg": "用户登录",
  "user_id": "12345",
  "ip": "192.168.1.1"
}
```

## 🛠️ 使用方法

### 基本日志记录

```go
import "github.com/sirupsen/logrus"

// 不同级别的日志
logrus.Info("这是信息日志")
logrus.Warn("这是警告日志")
logrus.Error("这是错误日志")
logrus.Debug("这是调试日志")
```

### 结构化日志

```go
logrus.WithFields(logrus.Fields{
    "user_id": "12345",
    "action":  "login",
    "ip":      "192.168.1.1",
}).Info("用户登录")
```

### 日志管理器

```go
import "volcengine-go-server/pkg/logger"

// 创建日志管理器
logManager := logger.NewLogManager()

// 配置参数
logManager.SetKeepDays(7)                    // 保留7天
logManager.SetRotateInterval(24 * time.Hour) // 24小时轮转一次
logManager.SetCleanInterval(24 * time.Hour)  // 24小时清理一次

// 启动管理器
ctx := context.Background()
go logManager.Start(ctx)

// 手动操作
logManager.ForceRotate() // 强制轮转
logManager.ForceClean()  // 强制清理
```

## 📁 文件结构

```
logs/
├── app-2024-01-15.log    # 今天的日志
├── app-2024-01-14.log    # 昨天的日志
├── app-2024-01-13.log    # 前天的日志
└── ...                   # 更早的日志（根据保留策略）
```

## 🔧 管理命令

### Make命令

```bash
# 测试日志功能
make test-logger

# 查看日志文件
make show-logs

# 清理日志文件
make clean-logs
```

### 手动操作

```bash
# 查看今天的日志
tail -f logs/app-$(date +%Y-%m-%d).log

# 查看所有日志文件
ls -la logs/

# 搜索特定内容
grep "ERROR" logs/app-*.log

# 统计日志数量
wc -l logs/app-*.log
```

## 🐳 Docker支持

### 日志目录挂载

```yaml
# docker-compose.yml
services:
  api-server:
    volumes:
      - ./logs:/app/logs  # 挂载日志目录
```

### 容器内日志查看

```bash
# 进入容器
docker exec -it container_name sh

# 查看日志
tail -f logs/app-$(date +%Y-%m-%d).log
```

## 📊 监控和分析

### 日志分析工具

推荐使用以下工具分析日志：

1. **ELK Stack** (Elasticsearch + Logstash + Kibana)
2. **Grafana Loki**
3. **Fluentd**
4. **Prometheus + Grafana**

### 日志指标

可以监控的关键指标：
- 日志文件大小
- 错误日志数量
- 请求响应时间
- 用户活动统计

## 🚨 故障排除

### 常见问题

1. **日志文件无法创建**
   ```bash
   # 检查目录权限
   ls -la logs/
   
   # 创建目录
   mkdir -p logs
   chmod 755 logs
   ```

2. **日志轮转失败**
   ```bash
   # 检查磁盘空间
   df -h
   
   # 检查文件权限
   ls -la logs/
   ```

3. **日志清理不工作**
   ```bash
   # 手动清理测试
   make test-logger
   
   # 检查环境变量
   echo $LOG_KEEP_DAYS
   ```

### 调试模式

```bash
# 启用调试日志
export LOG_LEVEL=debug

# 运行测试
make test-logger
```

## 🔒 安全考虑

### 敏感信息过滤

```go
// 避免记录敏感信息
logrus.WithFields(logrus.Fields{
    "user_id": userID,
    "action":  "login",
    // 不要记录密码、token等敏感信息
}).Info("用户操作")
```

### 日志文件权限

```bash
# 设置适当的文件权限
chmod 640 logs/*.log  # 只有owner和group可读写
```

## 📈 性能优化

### 异步日志

对于高并发场景，可以考虑使用异步日志：

```go
// 使用缓冲写入
logrus.SetOutput(bufio.NewWriter(multiWriter))
```

### 日志级别控制

```go
// 生产环境建议使用info级别
if environment == "production" {
    logrus.SetLevel(logrus.InfoLevel)
} else {
    logrus.SetLevel(logrus.DebugLevel)
}
```

## 📝 最佳实践

1. **结构化日志**: 使用WithFields记录结构化信息
2. **适当级别**: 根据重要性选择合适的日志级别
3. **避免敏感信息**: 不要记录密码、token等敏感数据
4. **性能考虑**: 避免在高频路径记录过多日志
5. **监控告警**: 设置错误日志的监控告警
6. **定期清理**: 根据业务需求设置合适的保留策略 